## 객체지향 프로그래밍 OOP(Object-Oriented Programming)
### OOP 장점과 단점
- 장점: 코드의 재사용성 강화, 유지보수 용이, 간결한 코드
- 단점: 처리속도 상대적으로 느림, 프로그램을 설계할 때 많은 고민과 시간을 투자

### OOP 4대 특징
- 추상화: 추상화는 인터페이스로 클래스들의 공통적인 특성(변수, 메소드)들을 묶어 표현
  - 인터페이스와 구현을 분리함으로써, 객체가 가진 특성 중 필수 속성만으로 객체를 묘사하고 유사성만을 표현하며 세부적인 상세 사항은 각 객체에 따라 다르게 구현되도록 할 수 있다. 

- 캡슐화: 캡슐화는 데이터(속성)와 데이터를 처리하는 함수(메소드)를 하나로 결합
  - 객체 내 데이터에 대한 보안, 보호, 외부 접근 제한 등을 위한 것이며 이렇게 내부 데이터 접근을 제한하는 것을 정보 은닉화(Information hiding) 이라고 한다.
  - 객체들 간 메시지를 주고받을 때 각 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간 결합도가 낮아진다.
  - 캡슐화된 객체들은 재사용이 용이하다.

- 상속성: 상속은 기존 클래스를 수정하지 않으면서도 이미 정의되어 있는 내용을 확장해서 사용할 수 있는 방법을 제공
  - 상속을 받은 자식클래스는 부모클래스의 특성과 기능을 사용할 수 있다.
  - 기능의 일부분을 변경하는 경우, 자식클래스에서 수정하여 사용할 수 있다.
  - 캡슐화를 유지하므로, 클래스의 재사용을 용이하게 만들어준다.

- 다형성: 다형성은 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때, 하나의 메시지에 대해 각 객체(클래스)가 가지고 있는 고유한 방법으로 응답할수 있는 능력을 의미
  - 오버로딩(Overloading): 같은 이름의 메소드를 여러개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술
  - 오버라이딩(Overriding): 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 재정의 하는 기술

### OOP 5대 설계 원칙
- 단일 책임 원칙, SRP(Single Responsiblity Principle)
  - 하나의 클래스는 하나의 책임만 가져야 한다.
  - 객체는 오직 하나의 변경의 이유만을 가진다.

- 개방-폐쇄 원칙, OCP(Open-Closed Principle)
  - 객체는 확장에는 개방적, 수정에는 폐쇄적이어야 한다,

- 리스코프 치환 원칙, LSP(Liskov Substitution Princple)
  - 자식클래스는 언제든지 부모클래스를 대체할 수 있다.

- 인터페이스 분리 원칙, ISP(Interface Segregation Principle)
  - 하나의 범용적인 인터페이스보다 여러 개의 구체적인 인터페이스가 좋다는 원칙

- 의존관계 역전 원칙, DIP(Dependency Inversion Principle)
  - 의존 관계를 맺을 때 변화하기 쉬운 것, 자주 변화하는 것보다는 변화하기 어려운것, 거의 변화가 없는 것에 의존하라는 원칙

## 디자인패턴
- 상황에 따라 자주 쓰이거나 효율적인 설계 방법을 정리한 코딩 방법론.

### 주요 디자인패턴의 종류
- 싱글톤 패턴: 오직 한개의 클래스 인스턴스(static)만 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.
  - 일종의 전역 변수. 모든 곳에서 접근하여 공유할 수 있는 단 하나의 인스턴스.
  - 여러 클래스와 커플링될 수 있다.
  - 멀티 쓰레드 환경에서 문제 발생, 모든 곳에서 접근이 가능하므로 race condition 발생한다.

- 컴포넌트 패턴: 로직을 기능별로 컴포넌트화 하는 것. 기능들을 나누어 각각 독립적인 클래스로 분리
  - 한 개체가 여러 분야를 서로 커플링 없이 다룰 수 있게 해준다.
  - 컴포넌트만 수정하면 되서 요구사항에 대한 대처가 빨라 유지보수시 편하다.
  - 유니티는 컴포넌트 구조를 사용하고 있다.

- 커맨드 패턴: 함수 호출을 자체를 실체화. 즉, 객체로 감싼 것
  - 요청 자체를 캡슐화 하는 것으로 요청이 서로 다른 사용자를 매개 변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원한다.
  - 함수 호출을 객체로 만들었기 때문에 디커플링으로 코드가 유연하다.
  - 게임 프로그래밍에서의 사용 예로 입력 키 변경, 실행 취소, 재실행 등이 있다.

- 상태 패턴: 상태를 별도의 클래스로 캡슐화한 다음 현재 상태를 나타내는 객체에게 행동을 위임

- 옵저버 패턴: 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가서 자동으로 내용이 갱신되는 방식

## 컴파일시, 작동 순서
- 전처리기 -> 컴파일러 -> 어셈블러 -> 링커
  - 전처리(Preprocess): 소스 내부에 #로 시작되는 것들 실행. 컴파일 전에 어떤 순서로 컴파일 할지 결정, 가동성 높임
  - 컴파일(Compile): 소스파일을 기계어로 번역. 에러, 경고 발생. C컴파일 -> 어셈블리어 -> 어셈블리컴파일 -> 기계어. .obj파일(기계어) 생성
  - 링크(Link): .obj파일과 소스코드에서 사용되는 함수가 있는  .lib파일을 이용, 실행 가능한 파일을 만듦. 변수, 함수가 없을 시 오류 발생. .exe파일 생성

### 전처리기 지시어
- [플랫폼별](https://docs.unity3d.com/kr/2022.1/Manual/PlatformDependentCompilation.html)
- 심볼별(#define-#undef), 조건별(#if-#else-#elif-#endif), 지역별(#region-#endregion)

## 동기-비동기
- 동기 : 요청과 결과가 동시에 일어남
  - 함수의 결과를 호출한 곳에서 처리
- 비동기 : 요청과 결과가 동시에 일어나지 않음
  - 함수의 결과를 호출한 쪽에서 처리하지 않음

## 프레임워크와 라이브러리
- 프레임워크: 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머가 그 안에 필요한 코드를 작성
- 라이브러리: 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것

## 추상클래스와 인터페이스
- 반드시 구현해야 할 것, 구현없이 메서드 선언만 포함
- 의도하지 않은 정보 공개 방지

### 추상클래스와 인터페이스의 차이점
- 추상클래스: 단일 상속, 접근제한자, 빠름, 필드X
- 인터페이스: 다중 상속, public, 느림, 필드O

## Mono
- 멀티플랫폼으로 지원되는 환경
- Runtime 시스템에서 자동으로 메모리 관리를 수행

## Garbage Collector
- 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요 없게 된 영역을 해제하는 기능
  - GC가 일어나는 타이밍이나 시간 예측이 어려움
  - 어떤 메모리를 해제할지 결정하는 데 비용이 듬

### 세대별 GC
- 메모리를 구역별로 나누어 빨리 해제될 객체와 오래 남아있을 객체를 따로 관리 (메모리를 0, 1, 2세대로 구분)
  - 0세대는 방금 생성된 객체나 빨리 사라질것으로 예상되는 객체
  - 2세대는 오래남을 것으로 예상되는 객체로 나눔

### 점진적 GC
- Profiler에 'GC Alloc'에서 GC 스파이크를 확인 -> incremental GC (Experimental)를 체크
- GC가 작업수행 간 시간이 다소 소요, 이 작업에 시간을 낭비해서는 안 되는 시점에 이런 상황이 발생할 수도 있다는 점

## Legacy 애니메이션과 Unity Mecanim의 차이
- Legacy: 같은 구조를 가지지만 모델마다 걷기 애니메이션이 모두 구현
- Unity Mecanim: 같은 구조(뼈대)를 갖는 모델들은 하나의 애니메이션을 공유

## Unity NGUI, UGUI
- NGUI: C#, 콜라이더 이벤트, 패널딥스(zOrder)
- UGUI: 일부 C++, 레이캐스트 이벤트, 하이어라키 순서(zOrder), RectTransform

## Unity Coroutine
- 멀티스레드는 아니지만 일부 기능처럼 활용 가능 (IEnumerator를 반환 하는 시점)

## Unity Invoke
- Invoke("Explode", fuseTime);
- 폭발이 수류탄과 같은 오브젝트에서 발생하는 경우 약간의 지연 시간 이후 또는 오브젝트가 타겟과 접촉한 시점

## Unity Life Cycle
- Awake(), OnEnable(), Start(), FixedUpdate(), ~Physics~, Update(), ~Anim~, LateUpdate(), ~Rendering~, OnApplicationQuit(), OnDisable(), OnDestroy()

## Unity Update
- 순서대로 FixedUpdate(), Update(), LateUpdate()
  - FixedUpdate(): 물리 효과가 적용된(Rigidbody) 오브젝트를 조정할 때 사용
  - Update(): 스크립트가 활성화(enabled) 상태일 때, 매 프레임마다 호출
  - LateUpdate(): 주로 오브젝트를 따라가게 하는 카메라와 같은 곳에 자주 사용

