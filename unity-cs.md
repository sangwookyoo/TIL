## 객체지향 프로그래밍 OOP(Object-Oriented Programming)
### OOP 장점과 단점
- 장점: 코드의 재사용성 강화, 유지보수 용이, 간결한 코드
- 단점: 처리속도 상대적으로 느림, 프로그램을 설계할 때 많은 고민과 시간을 투자

### OOP 4대 특징
- 추상화: 추상화는 인터페이스로 클래스들의 공통적인 특성(변수, 메소드)들을 묶어 표현
  - 인터페이스와 구현을 분리함으로써, 객체가 가진 특성 중 필수 속성만으로 객체를 묘사하고 유사성만을 표현하며 세부적인 상세 사항은 각 객체에 따라 다르게 구현되도록 할 수 있다. 

- 캡슐화: 캡슐화는 데이터(속성)와 데이터를 처리하는 함수(메소드)를 하나로 결합
  - 객체 내 데이터에 대한 보안, 보호, 외부 접근 제한 등을 위한 것이며 이렇게 내부 데이터 접근을 제한하는 것을 정보 은닉화(Information hiding) 이라고 한다.
  - 객체들 간 메시지를 주고받을 때 각 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간 결합도가 낮아진다.
  - 캡슐화된 객체들은 재사용이 용이하다.

- 상속성: 상속은 기존 클래스를 수정하지 않으면서도 이미 정의되어 있는 내용을 확장해서 사용할 수 있는 방법을 제공
  - 상속을 받은 자식클래스는 부모클래스의 특성과 기능을 사용할 수 있다.
  - 기능의 일부분을 변경하는 경우, 자식클래스에서 수정하여 사용할 수 있다.
  - 캡슐화를 유지하므로, 클래스의 재사용을 용이하게 만들어준다.

- 다형성: 다형성은 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때, 하나의 메시지에 대해 각 객체(클래스)가 가지고 있는 고유한 방법으로 응답할수 있는 능력을 의미
  - 오버로딩(Overloading): 같은 이름의 메소드를 여러개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술
  - 오버라이딩(Overriding): 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 재정의 하는 기술

### OOP 5대 설계 원칙
- 단일 책임 원칙, SRP(Single Responsiblity Principle)
  - 하나의 클래스는 하나의 책임만 가져야 한다.
  - 객체는 오직 하나의 변경의 이유만을 가진다.

- 개방-폐쇄 원칙, OCP(Open-Closed Principle)
  - 객체는 확장에는 개방적, 수정에는 폐쇄적이어야 한다,

- 리스코프 치환 원칙, LSP(Liskov Substitution Princple)
  - 자식클래스는 언제든지 부모클래스를 대체할 수 있다.

- 인터페이스 분리 원칙, ISP(Interface Segregation Principle)
  - 하나의 범용적인 인터페이스보다 여러 개의 구체적인 인터페이스가 좋다는 원칙

- 의존관계 역전 원칙, DIP(Dependency Inversion Principle)
  - 의존 관계를 맺을 때 변화하기 쉬운 것, 자주 변화하는 것보다는 변화하기 어려운것, 거의 변화가 없는 것에 의존하라는 원칙

## 디자인패턴
- 상황에 따라 자주 쓰이거나 효율적인 설계 방법을 정리한 코딩 방법론.

### 주요 디자인패턴의 종류
- 싱글톤 패턴: 오직 한개의 클래스 인스턴스(static)만 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.
  - 일종의 전역 변수. 모든 곳에서 접근하여 공유할 수 있는 단 하나의 인스턴스.
  - 여러 클래스와 커플링될 수 있다.
  - 멀티 쓰레드 환경에서 문제 발생, 모든 곳에서 접근이 가능하므로 race condition 발생한다.

- 컴포넌트 패턴: 로직을 기능별로 컴포넌트화 하는 것. 기능들을 나누어 각각 독립적인 클래스로 분리
  - 한 개체가 여러 분야를 서로 커플링 없이 다룰 수 있게 해준다.
  - 컴포넌트만 수정하면 되서 요구사항에 대한 대처가 빨라 유지보수시 편하다.
  - 유니티는 컴포넌트 구조를 사용하고 있다.

- 커맨드 패턴: 함수 호출을 자체를 실체화. 즉, 객체로 감싼 것
  - 요청 자체를 캡슐화 하는 것으로 요청이 서로 다른 사용자를 매개 변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원한다.
  - 함수 호출을 객체로 만들었기 때문에 디커플링으로 코드가 유연하다.
  - 게임 프로그래밍에서의 사용 예로 입력 키 변경, 실행 취소, 재실행 등이 있다.

- 상태 패턴: 상태를 별도의 클래스로 캡슐화한 다음 현재 상태를 나타내는 객체에게 행동을 위임

- 옵저버 패턴: 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가서 자동으로 내용이 갱신되는 방식

## 컴파일시, 작동 순서
- 전처리기 -> 컴파일러 -> 어셈블러 -> 링커
  - 전처리(Preprocess): 소스 내부에 #로 시작되는 것들 실행. 컴파일 전에 어떤 순서로 컴파일 할지 결정, 가동성 높임
  - 컴파일(Compile): 소스파일을 기계어로 번역. 에러, 경고 발생. C컴파일 -> 어셈블리어 -> 어셈블리컴파일 -> 기계어. .obj파일(기계어) 생성
  - 링크(Link): .obj파일과 소스코드에서 사용되는 함수가 있는  .lib파일을 이용, 실행 가능한 파일을 만듦. 변수, 함수가 없을 시 오류 발생. .exe파일 생성

### 전처리기 지시어
- [플랫폼별](https://docs.unity3d.com/kr/2022.1/Manual/PlatformDependentCompilation.html)
- 심볼별(#define-#undef), 조건별(#if-#else-#elif-#endif), 지역별(#region-#endregion)

## 동기-비동기
- 동기 : 요청과 결과가 동시에 일어남
  - 함수의 결과를 호출한 곳에서 처리
- 비동기 : 요청과 결과가 동시에 일어나지 않음
  - 함수의 결과를 호출한 쪽에서 처리하지 않음

## 프레임워크와 라이브러리
- 프레임워크: 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머가 그 안에 필요한 코드를 작성
- 라이브러리: 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것

## 추상클래스와 인터페이스
- 반드시 구현해야 할 것, 구현없이 메서드 선언만 포함
- 의도하지 않은 정보 공개 방지

### 추상클래스와 인터페이스의 차이점
- 추상클래스: 단일 상속, 접근제한자, 빠름, 필드X
- 인터페이스: 다중 상속, public, 느림, 필드O

## Collection
- 데이터타입 선언(제네릭): List(가변배열), Dictionary(HashMap), Stack(LIFO), Queue(FIFO)
- 데이터타입 미선언(오브젝트): ArrayList, Hashtable
  - 어떤 데이터든 다 담을수 있지만, Boxing-Unboxing이 자주 일어난다

### 맵과 해쉬맵
- 맵: 균형 이진 트리(레드블랙트리), 삽입과 동시에 자동으로 정렬
- 해쉬맵(Unordered Map): 해쉬 테이블. 정렬 할 필요가 없음. 키 값을 대입하여 나온 번호에 벨류를 저장.
- 맵의 시간복잡도는 O(log N), 해쉬맵의 시간복잡도는 O(1)
- 일반적으로 데이터 양이 많을 때 맵보다 해쉬맵이 빠름 (문자열일 때 더 복잡)

#### 기타 알고리즘
- KMP: 문자열 검색을 위한 알고리즘, O(N)
- dijkstra: 모든 정점까지의 최단거리, O(V^2)

### 배열과 리스트
- 모든 원소의 값을 한 번에 읽어야 한다면 연결 리스트, 특정한 원소만 알고 싶으면 배열
  - 배열: 크기고정, 빠르게 접근/검색
  - 리스트: 동적, 접근/검색 용이

## 내적과 외적
- 내적: 스칼라 (크기)
- 외적: 벡터 (크기, 방향)

## Stack Heap
- 값 타입의 변수가 저장되는 위치는 Stack 메모리에 위치하고, 참조 타입은 Heap 메모리에 위치

### Stack
- 빠르고 메모리 크기 제한, LIFO
- 메소드 내 변수 접근

### Heap
- 느리고 메모리 크기 제한없음, GC
- 전역접근

## Boxing-Unboxing
- Boxing: 값 타입을 오브젝트 형식으로 변환하는 것, 값 형식 -> 참조 형식(스택 영역에서 힙 영역)
- Unboxing: 오브젝트 형식에서 값 형식으로 변환하는 것, 참조 형식 -> 값 형식(힙 영역에서 스택 영역)

## Mono
- 멀티플랫폼으로 지원되는 환경
- Runtime 시스템에서 자동으로 메모리 관리를 수행

## Garbage Collector
- 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요 없게 된 영역을 해제하는 기능
  - GC가 일어나는 타이밍이나 시간 예측이 어려움
  - 어떤 메모리를 해제할지 결정하는 데 비용이 듬

### 세대별 GC
- 메모리를 구역별로 나누어 빨리 해제될 객체와 오래 남아있을 객체를 따로 관리 (메모리를 0, 1, 2세대로 구분)
  - 0세대는 방금 생성된 객체나 빨리 사라질것으로 예상되는 객체
  - 2세대는 오래남을 것으로 예상되는 객체로 나눔

### 점진적 GC
- Profiler에 'GC Alloc'에서 GC 스파이크를 확인 -> incremental GC (Experimental)를 체크
- GC가 작업수행 간 시간이 다소 소요, 이 작업에 시간을 낭비해서는 안 되는 시점에 이런 상황이 발생할 수도 있다는 점

## Legacy 애니메이션과 Unity Mecanim의 차이
- Legacy: 같은 구조를 가지지만 모델마다 걷기 애니메이션이 모두 구현
- Unity Mecanim: 같은 구조(뼈대)를 갖는 모델들은 하나의 애니메이션을 공유

## Unity NGUI, UGUI
- NGUI: C#, 콜라이더 이벤트, 패널딥스(zOrder)
- UGUI: 일부 C++, 레이캐스트 이벤트, 하이어라키 순서(zOrder), RectTransform

## Unity IEnumerator
- 데이터의 목록을 하나씩 넘겨줄 때 사용되는 인터페이스

### Coroutine
- 멀티스레드는 아니지만 일부 기능처럼 활용 가능 (IEnumerator를 반환 하는 시점)
- 여러 개의 루틴이 동시에 실행되며 서로 제어를 넘겨주는 방식
- 실제로는 단일 쓰레드 이기 때문에 멀티쓰레드가 가지는 교착 상태 결합 등의 문제에서 자유로움

### yield return
- 일시적으로 CPU 권한을 다른 함수에 위임
- 일반적인 함수는 반환하는 즉시 함수를 완전히 끝내는 것인데, 열거자는 권한을 잠시 위임하는 것이기 때문에 다른 함수로 권한을 넘기더라도 자신이 실행하고 있던 상태를 기억

### Invoke의 차이
- Invoke("Explode", fuseTime);
- 매개변수로 넘겨주는 시간 만큼 함수를 지연호출
- 폭발이 수류탄과 같은 오브젝트에서 발생하는 경우 약간의 지연 시간 이후 또는 오브젝트가 타겟과 접촉한 시점

## [Unity Script Lifecycle Flowchart](https://docs.unity3d.com/2021.3/Documentation/Manual/ExecutionOrder.html)
- Awake(), OnEnable(), Start(), FixedUpdate(), Physics~, Update(), Anim~, LateUpdate(), Rendering~, OnApplicationQuit(), OnDisable(), OnDestroy()

### Unity Update
- 순서대로 FixedUpdate(), Update(), LateUpdate()
  - FixedUpdate(): 물리 효과가 적용된(Rigidbody) 오브젝트를 조정할 때 사용
  - Update(): 스크립트가 활성화(enabled) 상태일 때, 매 프레임마다 호출
  - LateUpdate(): 주로 오브젝트를 따라가게 하는 카메라와 같은 곳에 자주 사용

## Unity Rendering Pipeline
- 3차원 장면의 모습에 근거해서 2차원 이미지를 생성하는데 GPU 메로리 자원들을 사용하는 일련의 단계
1. 입력조립: GPU가 CPU로부터 정점 데이터를 전달 받아서 프리미티브(삼각형) 생성
2. 정점 쉐이더: ObjectSpace에서 ClipSpace까지 정점들의 공간변환을 수행
3. 래스터 라이저: ClipSpace의 정점 데이터를 Viewport로 변환하고, 정점 데이터를 기반으로 보간된 프래그먼드(픽셀데이터)를 생성
4. 픽셀(프래그먼트)쉐이더: 프래그먼트를 입력 받아 화면에 그려질 모든 픽셀의 색상과 깊이 값을 출력
5. 출력병합: Z-Test,StencilText,AlphaBlending등을 통해 최종적으로 화면에 그려질 색상을 결정

### Index Buffer
- 사각형이나 메쉬를 그리는 경우 중복된 버텍스를 효율적으로 사용하는 방법
- 인덱스를 사용하지 않고 그리려면 중복되는 점도 또 저장해 줘야 한다.
- 저장하는 대신 몇번째 점 인지만 숫자 하나 써주면 되기 때문에 효율적이다.

### 월드, 뷰, 프로젝션 변환 정의
- 월드 변환: 기본적으로 로컬좌표계를 가지지만 동일한 공간에 띄우기 위해 월드좌표로 바꿔주는 것 (변환행렬)
- 뷰 변환: 카메라 변환
- 프로젝션 변환: 앞에는 3차원이지만 모니터는 2차원 모니터에 띄우기 위해 투영변환

### 역행렬의 용도 (빌보드 동작원리)
- 빌보드는 간단하게말해서 카메라가 어느 방향을 바라보아도 항상 카메라를 향하고 있도록 하는 기능이다. 
- 메시의 정면이 항상 카메라를 향하도록 하면 된다. 따라서 항상 카메라를 향하도록 하는 행렬을 만들면 된다.
- 따라서, 카메라 행렬중 회전행렬 성분만을 추출하여 역행렬을 구하면 그것이 빌보드의 회전행렬이 된다.
- 또는 특정 축에 대한 회전행렬만을 구하여 메시의 회전행렬로 사용하면 된다.

## TCP-UDP
- TCP: 인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
  - 느리지만 높은 신뢰성
  - 연결형 서비스로 가상 회선 방식을 제공

- UDP: 데이터를 데이터그램 단위로 처리하는 프로토콜
  - 빠르지만 낮은 신뢰성
  - 비연결형 서비스로 데이터그램 방식을 제공
